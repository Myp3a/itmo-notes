Начинаем с C, поскольку он прост.
Хотим фич, берем C++.
Со временем начинаем пользоваться шаблонами, т.к. они удобны.
Начинаем заботиться о производительности, возвращаемся к C++.
Апогеем всего возвращаемся к C, потому что он проще и быстрее.

Каждые 3 года выходит стандарт C++.

Почему не новые стандарты C++:
- Если функция появилась в 14, не факт, что она сохранится в 17
- Инструментарий может быть сырой
- Многоплатформенность ограничивает уровень стандарта
- **Нужно хорошо знать язык на уровне стандарта, чтобы с ним работать (1600+ страниц)**

Два уровня знания ЯП:
1. Library users (Application programmers) - уровень достаточен для написания любой программы (решения практической задачи).
2. Library writers - уровень разработки библиотек для других пользователей, используется большинство возможностей языка (максимально облегчить использование).

Синтаксис - то, как выглядят конструкции языка.
Семантика - смысловое значение синтаксической конструкции (конкретный синтаксис).
Идиоматика - то, как при помощи языка решаются типичные задачи.

> Без идиоматики - вы говорите на русском английскими словами
https://google.github.io/styleguide/cppguide.html

![[attachments/Pasted image 20240914105802.png]]
Игра в покер:
```C++
int card;  // Порядковый номер карты

// Тип данных, перечисление - набор фиксированных значений. Дает удобное представление некоторого численного состояния
// Имена переменных находятся в глобальном пространстве имен
enum PlayerState {
	PS_ACTIVE,
	PS_FOLDED,
	PS_OUT
}

// Имена переменных находятся в своем пространстве имен
// Получаются через PlayerState::PS_ACTIVE
enum class PlayerState {
	PS_ACTIVE,
	PS_FOLDED,
	PS_OUT
}

// Объявление структуры игрока
struct Player {
	int cards[2];  // Карты в руке
	int stack;  // Кол-во фишек
	PlayerState state;  // Текущее состояние игрока
	char name[];  // Текущее имя
}

enum TableState {
	TS_PREFLOP,
	TS_FLOP,
	TS_TURN,
	TS_RIVER,
}

struct Table {
	Player players[8];  //  Массив игроков
	int dealer_index;  // Индекс текущего дилера
	int pot;  // Текущий банк
	int current_cards[5]; // Выложенные карты
	TableState state;  // Текущий статус игры
}

// Определение структуры стола
Table g_table;

const string NAMES[] = {"Petya", "Vasya", ...};  // Генерация контента, геймдизайнерская часть
// Программа не должна содержать контент! Лучше подгружать из файлов, мы только предоставляем инструменты для подключения ассетов.

void init_table() {
	for (int i = 0; i < 8; i++) {  // Для игроков от 0 до 7
		// Конструктор не нужен, т.к. место под Player уже выделено - мы записываем нужные данные туда.
		g_table.players[i].name = NAMES[i];
		g_table.players[i].cards[0] = -1;
		g_table.players[i].cards[1] = -1;
		g_table.players[i].stack = 100;
		g_table.players[i].state = PS_ACTIVE;
	}
}
```
Hello world на C++:
```C++
#include <iostream>  // директива препроцессора для подключения библиотеки

int main() {  // main(int argc, char* argv[]) - точка входа
	std::cout << "Hello world!\n";  // Вывод текста на консоль
}
```
Область видимости компилятора - некоторая часть программы, в котором компилятор "видит" переменные и функции.
Declaration (объявление) - в текущей области видимости есть некоторое имя, которое является чем-то конкретным (имеет определенные аргументы).
Definition (определение) - связывает конкретное имя с конкретной реализацией. Показывает, какой код нужно сгенерировать компилятору.

Объявление переменной:
```C++
int a;  // тип имя;
a = 10;  // определение переменной;

int a;  // определение переменной
extern int a;  // объявление переменной
```

Препроцессор заменяет свои директивы на включение кода до тех пор, пока директив препроцессора не останется.
Потом файл компилируется в `.obj` файл с исходным кодом.
Затем линкер собирает объектные файлы с кодом и объединяет их в один исполняемый файл.

`std::cout` - стандартный вывод.
`std::cerr` - стандартный вывод ошибок.
`std::cin` - стандартный ввод.

```C++
typedef int card_t;  // Именование типа ("новый" тип)
// Везде, где используется card_t, будет использован int;
```

> Любимое развлечение программиста на C++ - писать свои строки, потому что строк нет

Строки хранятся в виде массива символов. Конец строки - `\0`.

Неймспейс - некоторая область видимости, содержащая функции и переменные. Существует для того, чтобы функции с одинаковыми названиями не пересекались.

```C++
using namespace std;  // Сказать, что все идентификаторы из неймспейса std
```
Так не стоит делать, можем случайно перемешать функции.

Глобальные переменные - не ок:
- Случайная модификация
- Возможность переопределить
- ?

Глобальные переменные попадают в область статических данных.

При загрузке программы в память ей выделяются несколько областей памяти:
- DSS - глобальные данные
	- g_table
- TEXT - код
	- void init_table
- ... - стек
	- Дополнительные данные для выполнения
	- Локальные данные
- Heap - динамическая память
	- Ручное управление памятью
		- malloc/free
		- new/delete

В C++ все хранится по значению, если не указано иное.

Если в структуре есть поля, у которых есть конструктор, то у структуры тоже появляется конструктор.

Специальные значения, которыми компилятор заполняет переменные, чтобы отслеживать неиспользуемые.
- 0xccccccc
- 0xcdcdcd