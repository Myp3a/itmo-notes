Преподаватель: Александров Эдуард Эмильевич

Цель: выровняться по C++, посмотреть, почему именно он в гейдеве. Посмотреть не на все возможности, посмотреть на взаимодействие, базовые вещи.

Практики в дистанте не будет, только лекции.
Четыре лабораторные работы, можно консультации на лекциях.
Отдельное занятие для сдачи и общения по лабам.
Три первые одинаковы для всех, последняя индивидуальная: геймдизайн простая, движки - мощная (менеджер памяти).

Сданные лабы - оценка пять.

---

Игра с точки зрения программиста:
- Программа
- Интерактивная система
- Реалтайм
- **Симуляция**
	- Интерактивная симуляция в реал-тайме
Интерактивная - предполагает взаимодействие.

Симуляция - формальная модель + решатель.
Математическая модель - набор абстракций и правил, строго математически. Может быть выражена различными математическими механизмами: уравнениями, конечными автоматами, правилами логики. Строго формализована и математически точна.
Решатель - некоторая программа, вычисляющая математическую модель.
*Есть движение - применяются диффуры.*
Симуляции в игре:
- Физика
- Поведение (ИИ)
- Рендеринг
- ...
Рендеринг решается отдельно от физики. Раньше - растеризация, отрисовка картинки.
Формальная модель наполняется данными. Решать и получать результат нужно на определенных данных.

Реал-тайм
Ограничение по времени, за которое должны выполниться все действия. Обычно время кадра (~16мс на 60FPS).
Игровой цикл (программирование) - некоторый цикл, результатом выполнения которого является новый кадр игры.
Кадр игры отображает:
- Состояние игрового мира
	- Отображение входного набора данных
- Ввод игрока
- Симуляция ИИ
- Симуляция физики
- ...
Обновление физики обычно отделяется от обновления рендеринга, чтобы при падении частоты кадров физика не изменялась (рассинхронизация).
Системные требования придуманы не просто так - они сделаны для того, чтобы укладываться во время кадра.
Учитывать возможности оборудования: с диска данные не достанешь быстрее, чем из оперативки, процессоры бывают разных частот...
Чем мощнее машина, тем больше возможностей симуляции мы можем предложить пользователю.
Бутылочное горлышко - прием, когда персонаж пробирается через узкое пространство: в этот момент подгружается следующий кусок уровня и выгружается предыдущий. Получается бесшовный геймплей, скрытый за геймдизайнерским приемом.
Существует множество различных приемов, облегчающих рендеринг без урона для качества картинки.
Основной алгоритм - определить, что видно, а что нет - и отрендерить только видимое.
Имплементаций достаточно много.
Если есть возможность, что произойдет рендеринг объекта - его стоит держать в памяти. Если объект вряд ли будет отрендерен/позволительна задержка в его отображении, то можно лениво подгружать.

Разработка программы
- Определить предметную область
- Конкретизировать - свойства, взаимосвязи, объекты
- Получить модель
- Конвертировать в язык программирования

Программы разрабатываются с использованием абстракций.
Абстракция - независимость от конкретной имплементации нижестоящего уровня.

Уровни абстракций
- Железо
- ОС
- Библиотеки
	- Библиотеки ОС (API ОС)
	- Библиотеки ЯП (с++ std::)
	- Сторонние библиотеки (движок, свободные разработчики)
	- Рантаймы (.NET, JVM)
		- Специальная ВМ, виртуализирующая все, что ниже
		- Предоставляет "виртуальный компьютер" с определенными возможностями
- Приложение (игра)

ОС работает в двух системах - режим ядра (привилегированный режим) и режим пользователя (верхнеуровневые сервисы).
Виртуальный компьютер не даст требуемого уровня производительности.

Чаще всего выбирается ООП - так сложилось исторически.
*Существует еще Data-oriented programming*
*Про C++ знают больше всего разработчики браузеров и разработчики игр*
C# или Java не умеют иного, кроме ООП - поэтому там он обязателен. Для игр ООП не особо применим.
Почему не ООП:
- Ориентирован на пользователя, а не на железо
- Концептуальные проблемы
	- Анализ программ в терминах реального мира
	- Проблема хрупкого базового класса
		- Изменения в базовом классе меняют всю иерархию
		- Новое поведение - новый класс, иначе есть шанс нарушить всю программу
	- Нечитаемо при долгом существовании и проработке
	- Запрет наследования типов данных
- Три столпа ООП не имеют полезного применения

Почему не переходят
- Переходят, но со временем
- Нет возможности (Java)
- Захламляется только со временем

*SOLID*

Дать геймдизайнеру визуальную систему, в которой можно задавать параметры.

Domain-driven design
Существительные - сущности.
Набор сущностей - словарь системы.
*Дилер сдает игроку две карты: сущности "дилер", "игрок" и "карта"*
*Карта: поля Rank и Suite*
Глаголы - связи и действия между сущностями.
*Дилер может выдавать карты игроку*
Сущность = класс, действие = метод. Легко перейти к программному представлению.
```C++
class Dealer {
public:
	void deal(Player& player);
}

class Player {
}

enum Suite {
	Hearts,
	Diamonds,
	Clubs,
	Spades
}

class Card {
private:
	int rank;
	Suite suite;
}
```
Методология определяет набор сущностей и их взаимодействия.
Язык программирования предоставляет инструменты для создания результирующих сущностей.
**Что мы хотим делать с картами?**
- Оценить комбинацию
- *элементарные методы вроде принта*
Представление карты будет зависеть от того, какое представление требует эффективный алгоритм вычисления покерной руки.
Вариант 1 (массив)
- Берем стандартный порядок карт
- Нумеруем карты
- Заводим массив, содержащий номера карт в руке
Вариант 2 (битовая маска)
- Стандартный нумерованный порядок карт
- Битовая маска определяет, есть ли карта в руке

Time-vs-space tradeoff
Железо выделяет процессорное время и объем памяти.
Чем эффективнее алгоритм - тем меньше процессорного времени он тратит.
Часто можно разменивать один ресурс на другой - за счет большего потребления памяти уменьшить процессорное время или наоборот.
В случае с фиксированным временем рендеринга чаще всего используется больше памяти.
При суровых ограничениях железа иногда наоборот (консоли, мобилки).

> не надо вместе с водой выплескивать младенца

ООП имеет свои плюсы в некоторых стратегиях и поэтому о нем стоит помнить.

Data-driven design
Хранить и применять данные в тех форматах, в которых с ними удобно работать оборудованию. Если данные разложены хорошо, то алгоритмы максимально просты и эффективны.

Стек, очередь - дисциплина доступа к данным.
Хеш-таблица, деревья - решение задач поиска, организация хранения.
Список, массив - хранение данных.

Неверное суждение: выбор между списком и массивом зависит от стоимости операций. Стоит выбирать так, чтобы самая частая задача (вставка, чтение) занимала меньше всего времени.

Вектор лучше:
- Меньше оверхед
- Кеширование/префетч за счет последовательного расположения в памяти
Всегда берем вектор, список - просто концептуальная структура.

С одной стороны понимать происходящее в предметной области, с другой - компиляцию, хранение в памяти, прохождение данных через механизмы - только так можно написать программу эффективно.

